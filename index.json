[{"categories":null,"content":"What is life?","date":"2022-06-17","objectID":"/tt/","tags":null,"title":"对LoveIt主题的个人改动","uri":"/tt/"},{"categories":null,"content":" 首先附上LoveIt主题的doc。本人不会前端，完全是面向搜索引擎和各个大佬（尤其感谢雨临Lewis）的教程进行修改，主要修改了原主题css样式边边角角的一些效果，此处留档。 ","date":"2022-06-17","objectID":"/tt/:0:0","tags":null,"title":"对LoveIt主题的个人改动","uri":"/tt/"},{"categories":null,"content":"修改某些css样式 Note\r根据雨临Lewis大佬的这篇文章建议： LoveIt主题提供了一个自定义的_custom.scss，可以在该文件里添加自定义的css样式。该文件目录位于\\themes\\LoveIt\\assets\\css\\_custom.scss，不建议直接在该文件里写css代码。 Hugo在渲染页面时优先读取站点根目录下的同名字的目录和文件，所以可以利用这个特点来美化主题。只需要把想修改的主题模板文件拷贝到根目录下同样的目录中并进行修改，这样就可以在不改动原本的主题文件的情况下实现主题美化。 首先在站点根目录下创建一个自定义的文件：\\assets\\css\\_custom.scss，这样Hugo就会最终以该文件来渲染页面的样式。 加圆角：通过F12定位到样式后参考菜鸟CSS教程修改border-radius，其中还可以单独调各个方向圆角，详看教程。 颜色：通过VsCode插件和浏览器开发工具便捷可视化修改。 磨砂效果：将background-color调成rgba带透明度的格式，然后加上backdrop-filter: blur(4px)，其中4px可以自定义调整，效果如图： 磨砂效果 ","date":"2022-06-17","objectID":"/tt/:1:0","tags":null,"title":"对LoveIt主题的个人改动","uri":"/tt/"},{"categories":null,"content":"设置背景轮播 参照雨临Lewis大佬的这篇文章。 ","date":"2022-06-17","objectID":"/tt/:2:0","tags":null,"title":"对LoveIt主题的个人改动","uri":"/tt/"},{"categories":null,"content":"添加DPlayer播放器 参照Jay的这篇文章，其中不知道为什么引入DPlayer的css和Js失败，后看到Kreee的这篇文章，直接将以下代码： \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/dplayer@1.25.0/dist/DPlayer.min.css\"\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/dplayer@1.25.0/dist/DPlayer.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/hls.js@0.13.2/dist/hls.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/flv.js@1.5.0/dist/flv.min.js\"\u003e\u003c/script\u003e 复制到\\mysite\\layouts\\_default\\baseof.html的\u003chead\u003e \u003c/head\u003e中间，DPlayer成功加载，基本使用语法如下： {{\u003c video id=\"u\" url=\"url\" pic=\"pic\"\u003e \u003e}} 其中id用来标识是同一个页面哪一个视频，url是视频地址，pic是视频封面，效果如下： ","date":"2022-06-17","objectID":"/tt/:3:0","tags":null,"title":"对LoveIt主题的个人改动","uri":"/tt/"},{"categories":null,"content":"修改侧边栏目录样式 详见这篇文章，下面是在其基础上的一些改动： [theme=dark] .toc { background: #43434a; opacity: 0.85; } [theme=dark] #toc-auto { border-left-color: #6f6a6a; } .toc .toc-content { font-size: 1rem; } .toc .toc-content code { border: none; color: #f9785e; font-size: 1em; } nav#TableOfContents ol { padding-inline-start: 20px; border-radius: 4px; \u0026 ol { padding-inline-start: 15px; font-size: .75rem; display: none; } \u0026 li.has-active ol { display: block; } } ","date":"2022-06-17","objectID":"/tt/:4:0","tags":null,"title":"对LoveIt主题的个人改动","uri":"/tt/"},{"categories":null,"content":"Python面试宝典 - 基础篇 - 2020 题目001: 在Python中如何实现单例模式。 点评：单例模式是指让一个类只能创建出唯一的实例，这个题目在面试中出现的频率极高，因为它考察的不仅仅是单例模式，更是对Python语言到底掌握到何种程度，建议大家用装饰器和元类这两种方式来实现单例模式，因为这两种方式的通用性最强，而且也可以顺便展示自己对装饰器和元类中两个关键知识点的理解。 方法一：使用装饰器实现单例模式。 from functools import wraps 的思 def singleton(cls): \"\"\"单例类装饰器\"\"\" instances = {} @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper @singleton class President: pass 扩展：装饰器是Python中非常有特色的语法，用一个函数去装饰另一个函数或类，为其添加额外的能力。通常通过装饰来实现的功能都属横切关注功能，也就是跟正常的业务逻辑没有必然联系，可以动态添加或移除的功能。装饰器可以为代码提供缓存、代理、上下文环境等服务，它是对设计模式中代理模式的践行。在写装饰器的时候，带装饰功能的函数（上面代码中的wrapper函数）通常都会用functools模块中的wraps再加以装饰，这个装饰器最重要的作用是给被装饰的类或函数动态添加一个__wrapped__属性，这个属性会将被装饰之前的类或函数保留下来，这样在我们不需要装饰功能的时候，可以通过它来取消装饰器，例如可以使用President = President.__wrapped__来取消对President类做的单例处理。需要提醒大家的是：上面的单例并不是线程安全的，如果要做到线程安全，需要对创建对象的代码进行加锁的处理。在Python中可以使用threading模块的RLock对象来提供锁，可以使用锁对象的acquire和release方法来实现加锁和解锁的操作。当然，更为简便的做法是使用锁对象的with上下文语法来进行隐式的加锁和解锁操作。 方法二：使用元类实现单例模式。 class SingletonMeta(type): \"\"\"自定义单例元类\"\"\" def __init__(cls, *args, **kwargs): cls.__instance = None super().__init__(*args, **kwargs) def __call__(cls, *args, **kwargs): if cls.__instance is None: cls.__instance = super().__call__(*args, **kwargs) return cls.__instance class President(metaclass=SingletonMeta): pass 扩展：Python是面向对象的编程语言，在面向对象的世界中，一切皆为对象。对象是通过类来创建的，而类本身也是对象，类这样的对象是通过元类来创建的。我们在定义类时，如果没有给一个类指定父类，那么默认的父类是object，如果没有给一个类指定元类，那么默认的元类是type。通过自定义的元类，我们可以改变一个类默认的行为，就如同上面的代码中，我们通过元类的__call__魔术方法，改变了President类的构造器那样。 补充：关于单例模式，在面试中还有可能被问到它的应用场景。通常一个对象的状态是被其他对象共享的，就可以将其设计为单例，例如项目中使用的数据库连接池对象和配置对象通常都是单例，这样才能保证所有地方获取到的数据库连接和配置信息是完全一致的；而且由于对象只有唯一的实例，因此从根本上避免了重复创建对象造成的时间和空间上的开销，也避免了对资源的多重占用。再举个例子，项目中的日志操作通常也会使用单例模式，这是因为共享的日志文件一直处于打开状态，只能有一个实例去操作它，否则在写入日志的时候会产生混乱。 题目002：不使用中间变量，交换两个变量a和b的值。 点评：典型的送人头的题目，通常交换两个变量需要借助一个中间变量，如果不允许使用中间变量，在其他编程语言中可以使用异或运算的方式来实现交换两个变量的值，但是Python中有更为简单明了的做法。 方法一： a = a ^ b b = a ^ b a = a ^ b 方法二： a, b = b, a 扩展：需要注意，a, b = b, a这种做法其实并不是元组解包，虽然很多人都这样认为。Python字节码指令中有ROT_TWO指令来支持这个操作，类似的还有ROT_THREE，对于3个以上的元素，如a, b, c, d = b, c, d, a，才会用到创建元组和元组解包。想知道你的代码对应的字节码指令，可以使用Python标准库中dis模块的dis函数来反汇编你的Python代码。 题目003：写一个删除列表中重复元素的函数，要求去重后元素相对位置保持不变。 点评：这个题目在初中级Python岗位面试的时候经常出现，题目源于《Python Cookbook》这本书第一章的第10个问题，有很多面试题其实都是这本书上的原题，所以建议大家有时间好好研读一下这本书。 def dedup(items): no_dup_items = [] seen = set() for item in items: if item not in seen: no_dup_items.append(item) seen.add(item) return no_dup_items 如果愿意也可以把上面的函数改造成一个生成器，代码如下所示。 def dedup(items): seen = set() for item in items: if item not in seen: yield item seen.add(item) 扩展：由于Python中的集合底层使用哈希存储，所以集合的in和not in成员运算在性能上远远优于列表，所以上面的代码我们使用了集合来保存已经出现过的元素。集合中的元素必须是hashable对象，因此上面的代码在列表元素不是hashable对象时会失效，要解决这个问题可以给函数增加一个参数，该参数可以设计为返回哈希码或hashable对象的函数。 题目004：假设你使用的是官方的CPython，说出下面代码的运行结果。 点评：下面的程序对实际开发并没有什么意义，但却是CPython中的一个大坑，这道题旨在考察面试者对官方的Python解释器到底了解到什么程度。 a, b, c, d = 1, 1, 1000, 1000 print(a is b, c is d) def foo(): e = 1000 f = 1000 print(e is f, e is d) g = 1 print(g is a) foo() 运行结果： True False True False True 上面代码中a is b的结果是True但c is d的结果是False，这一点的确让人费解。CPython解释器出于性能优化的考虑，把频繁使用的整数对象用一个叫small_ints的对象池缓存起来造成的。small_ints缓存的整数值被设定为[-5, 256]这个区间，也就是说，在任何引用这些整数的地方，都不需要重新创建int对象，而是直接引用缓存池中的对象。如果整数不在该范围内，那么即便两个整数的值相同，它们也是不同的对象。 CPython底层为了进一步提升性能还做了另一个设定，对于同一个代码块中值不在small_ints缓存范围内的整数，如果同一个代码块中已经存在一个值与其相同的整数对象，那么就直接引用该对象，否则创建新的int对象。需要大家注意的是，这条规则对数值型适用，但对字符串则需要考虑字符串的长度，这一点大家可以自行证明。 扩展：如果你用PyPy（另一种Python解释器实现，支持JIT，对CPython的缺点进行了改良，在性能上优于CPython，但对三方库的支持略差）来运行上面的代码，你会发现所有的输出都是True。 题目005：Lambda函数是什么，举例说明的它的应用场景。 点评：这个题目主要想考察的是Lambda函数的应用场景，潜台词是问你在项目中有没有使用过Lambda函数，具体在什么场景下会用到Lambda函数，借此来判断你写代码的能力。因为Lambda函数通常用在高阶函数中，主要的作用是通过向函数传入函数或让函数返回函数最终实现代码的解耦合。 Lambda函数也叫匿名函数，它是功能简单用一行代码就能实现的小型函数。Python中的Lambda函数只能写一个表达式，这个表达式的执行结果就是函数的返回值，不用写return关键字。Lambda函数因为没有名字，所以也不会跟其他函数发生命名冲突的问题。 扩展：面试的时候有可能还会考你用Lambda函数来实现一些功能，也就是用一行代码来实现题目要求的功能，例如：用一行代码实现求阶乘的函数，用一行代码实现求最大公约数的函数等。 fac = lambda x: __import__('functools').reduce(int.__mul__, range(1, x + 1), 1) gcd = lambda x, y: y % x and gcd(y % x, x) or x L","date":"2022-06-17","objectID":"/python/:1:0","tags":null,"title":"Python","uri":"/python/"},{"categories":null,"content":"小林家的龙女仆第七话","date":"2022-06-16","objectID":"/big/","tags":null,"title":"龙女仆第七话","uri":"/big/"},{"categories":null,"content":"3 ","date":"2022-06-16","objectID":"/big/:0:0","tags":null,"title":"龙女仆第七话","uri":"/big/"},{"categories":null,"content":"LIFE IS A FOOL","date":"2022-06-16","objectID":"/life/","tags":null,"title":"Life","uri":"/life/"},{"categories":null,"content":"Nobody can escape from death ","date":"2022-06-16","objectID":"/life/:0:0","tags":null,"title":"Life","uri":"/life/"},{"categories":null,"content":"Test ","date":"2022-06-16","objectID":"/life/:1:0","tags":null,"title":"Life","uri":"/life/"},{"categories":null,"content":"1 ","date":"2022-06-16","objectID":"/life/:2:0","tags":null,"title":"Life","uri":"/life/"},{"categories":null,"content":"2 Note\r一个 注意 横幅\rTip\r建议\r这套叙事方 ","date":"2022-06-16","objectID":"/life/:3:0","tags":null,"title":"Life","uri":"/life/"},{"categories":null,"content":"About Me Hi, this is Louis A noob CS learner… ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"MY EXPERIENCES Studied Energy and Power in university. Self-learning CS. Know a bit about C++ and Golang. Now taking a gap year… ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"tags ","date":"0001-01-01","objectID":"/tags/:0:0","tags":null,"title":"","uri":"/tags/"}]